{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Clidantic Typed Command Line Interfaces powered by Click and Pydantic . Clidantic tries to bridge the powerful typed data management provided by pydantic with the composability offered by click . Quickstart To install, simply run: pip install clidantic As you guessed, there are only two major dependencies, pydantic and click . Once the package is installed, you can create a CLI using pydantic models or configurations. from pydantic import BaseModel from clidantic import Parser # create your CLI params as a model class Arguments ( BaseModel ): field_a : str field_b : int field_c : bool = False # instantiate the CLI runner cli = Parser () # decorate functions with your models as input # to use it as CLI command @cli . command () def main ( args : Arguments ): print ( args ) # last, simply execute your CLI if __name__ == \"__main__\" : cli () Features Typed declarations CLI arguments are declared using pydantic models in plain Python code, without the need for string-based argument declarations such as argparse , or even vanilla click . IDE-friendly Models are standard Python classes with annotated arguments. Auto-completion, linting and other IDE features should all work as expected, without the need to guess argument names. Validation by default Using pydantic definitions, clidantic inherently leverages on its powerful validation features. Modularity Clidantic offers full control over the CLI, with composable commands, and composable models: input configurations are as simple as plain models, this means that every validation capability, including custom validators, apply here. Acknowledgements Clidantic is by no means an original idea: the project is a condensed and pratical version of ideas originated from this original discussion . Special thanks to @frederikaalund and the cyto library for comments and example code. Contributions Clidantic is in early development stage, but if you feel this project deserves more love, you're welcome! Feel free to suggest new features and changes on GitHub.","title":"Home"},{"location":"#clidantic","text":"Typed Command Line Interfaces powered by Click and Pydantic . Clidantic tries to bridge the powerful typed data management provided by pydantic with the composability offered by click .","title":"Clidantic"},{"location":"#quickstart","text":"To install, simply run: pip install clidantic As you guessed, there are only two major dependencies, pydantic and click . Once the package is installed, you can create a CLI using pydantic models or configurations. from pydantic import BaseModel from clidantic import Parser # create your CLI params as a model class Arguments ( BaseModel ): field_a : str field_b : int field_c : bool = False # instantiate the CLI runner cli = Parser () # decorate functions with your models as input # to use it as CLI command @cli . command () def main ( args : Arguments ): print ( args ) # last, simply execute your CLI if __name__ == \"__main__\" : cli ()","title":"Quickstart"},{"location":"#features","text":"Typed declarations CLI arguments are declared using pydantic models in plain Python code, without the need for string-based argument declarations such as argparse , or even vanilla click . IDE-friendly Models are standard Python classes with annotated arguments. Auto-completion, linting and other IDE features should all work as expected, without the need to guess argument names. Validation by default Using pydantic definitions, clidantic inherently leverages on its powerful validation features. Modularity Clidantic offers full control over the CLI, with composable commands, and composable models: input configurations are as simple as plain models, this means that every validation capability, including custom validators, apply here.","title":"Features"},{"location":"#acknowledgements","text":"Clidantic is by no means an original idea: the project is a condensed and pratical version of ideas originated from this original discussion . Special thanks to @frederikaalund and the cyto library for comments and example code.","title":"Acknowledgements"},{"location":"#contributions","text":"Clidantic is in early development stage, but if you feel this project deserves more love, you're welcome! Feel free to suggest new features and changes on GitHub.","title":"Contributions"},{"location":"guide/advanced/","text":"Advanced Topics Setuptools Integration When distributing a module or a package, it is often better to bundle any command line utility inside the package itself. There are many reasons for this, as explained by the click documentation . The integration simply requires to register the main cli instance as console entrypoint in a standard setup.py file. Following the example provided by click , we use a directory structure composed of two files: main.py setup.py The main.py script contains a minimal CLI to be executed, for instance: from clidantic import Parser cli = Parser () @cli . command () def function (): print ( \"Hello world!\" ) if __name__ == \"__main__\" : cli () Note that the __main__ block can still kept without issues. In the setup.py script it is now sufficient to indicate the main script as console entrypoint, for instance: from setuptools import setup setup ( name = 'test-cli' , version = '0.1.0' , py_modules = [ 'main' ], install_requires = [ 'clidantic' , ], entry_points = { 'console_scripts' : [ 'mycommand = main:cli' , ], }, ) In order to execute the main script as part of the package, the module needs to be installed: $ python3 -m venv .venv $ source .venv/bin/activate $ pip install -e . $ mycommand > Hello world! This is an absolutely minimal example with unconventional names, just to better highlight which components refer to which part. Of course, mycommand can be customized with a different name and different entrypoints. Fro more information, check out the click guide and the Python packaging guide . Customizing the help Currently, there is not much available to customize the help, the only functionality available at this time is the maximum content width . The default click width is set to 79 characters, while clidantic raises it to 119. To customize the extents of the help string, it is sufficient to provide the content_width keyword argument when calling the main CLI: main.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from pydantic import BaseModel , Field from clidantic import Parser class Config ( BaseModel ): name : str = Field ( alias = \"n\" , description = \"a long sentence that may be wrapped depending on the terminal width\" ) cli = Parser () @cli . command () def main ( config : Config ): print ( config ) if __name__ == \"__main__\" : cli ( content_width = 40 ) Executing this script will provide a shorter help, wrapping longer descriptions on multiple lines: $ python clid_test.py --help > Usage: clid_test.py [OPTIONS] > > Options: > --name TEXT a long sentence that may be > truncated depending on the terminal > width [required] > --help Show this message and exit.","title":"Advanced Topics"},{"location":"guide/advanced/#advanced-topics","text":"","title":"Advanced Topics"},{"location":"guide/advanced/#setuptools-integration","text":"When distributing a module or a package, it is often better to bundle any command line utility inside the package itself. There are many reasons for this, as explained by the click documentation . The integration simply requires to register the main cli instance as console entrypoint in a standard setup.py file. Following the example provided by click , we use a directory structure composed of two files: main.py setup.py The main.py script contains a minimal CLI to be executed, for instance: from clidantic import Parser cli = Parser () @cli . command () def function (): print ( \"Hello world!\" ) if __name__ == \"__main__\" : cli () Note that the __main__ block can still kept without issues. In the setup.py script it is now sufficient to indicate the main script as console entrypoint, for instance: from setuptools import setup setup ( name = 'test-cli' , version = '0.1.0' , py_modules = [ 'main' ], install_requires = [ 'clidantic' , ], entry_points = { 'console_scripts' : [ 'mycommand = main:cli' , ], }, ) In order to execute the main script as part of the package, the module needs to be installed: $ python3 -m venv .venv $ source .venv/bin/activate $ pip install -e . $ mycommand > Hello world! This is an absolutely minimal example with unconventional names, just to better highlight which components refer to which part. Of course, mycommand can be customized with a different name and different entrypoints. Fro more information, check out the click guide and the Python packaging guide .","title":"Setuptools Integration"},{"location":"guide/advanced/#customizing-the-help","text":"Currently, there is not much available to customize the help, the only functionality available at this time is the maximum content width . The default click width is set to 79 characters, while clidantic raises it to 119. To customize the extents of the help string, it is sufficient to provide the content_width keyword argument when calling the main CLI: main.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from pydantic import BaseModel , Field from clidantic import Parser class Config ( BaseModel ): name : str = Field ( alias = \"n\" , description = \"a long sentence that may be wrapped depending on the terminal width\" ) cli = Parser () @cli . command () def main ( config : Config ): print ( config ) if __name__ == \"__main__\" : cli ( content_width = 40 ) Executing this script will provide a shorter help, wrapping longer descriptions on multiple lines: $ python clid_test.py --help > Usage: clid_test.py [OPTIONS] > > Options: > --name TEXT a long sentence that may be > truncated depending on the terminal > width [required] > --help Show this message and exit.","title":"Customizing the help"},{"location":"guide/fields/","text":"Customization The help directive As in every command line interface, before any actual command is executed it is often required to consult the help . As usual, to print the available commands and their options it is sufficient to execute the command with the --help/-h option. For instance, a script like the following: main.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from pydantic import BaseModel from clidantic import Parser cli = Parser () class Config ( BaseModel ): name : str @cli . command () def hello ( args : Config ): print ( f \"Hi, { args . name } !\" ) if __name__ == \"__main__\" : cli () Will provide the following output: $ python main.py --help > Usage: main.py [OPTIONS] > > Options: > --name TEXT [required] > --help Show this message and exit. As you can notice, every field from the configuration model parsed by the command is converted into a click option and displayed in the help . Each field has a name, a type, an optional required flag and its description. In this specific example, the description is present for the help command only, while the name is missing one. Adding descriptions Defining configurations through types only does not allow for descriptive definitions. Pydantic allows for field descriptions through the Field class: main.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from pydantic import BaseModel , Field from clidantic import Parser cli = Parser () class Config ( BaseModel ): name : str = Field ( description = \"How I should call you\" ) @cli . command () def hello ( args : Config ): print ( f \"Oh, hi { args . name } !\" ) if __name__ == \"__main__\" : cli () This will allow fields to have more details in the help output: $ python main.py --help > Usage: main.py [OPTIONS] > > Options: > --name TEXT How I should call you [required] > --help Show this message and exit. Default values Models support default values by simply assigning them to the field: class Config ( BaseModel ): name : str = \"Mark\" age : int = 42 It is also possible to combine default values and descriptions through the Field class, for instance: main.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from pydantic import BaseModel , Field from clidantic import Parser cli = Parser () class Config ( BaseModel ): name : str = Field ( \"Mark\" , description = \"How I should call you\" ) @cli . command () def hello ( args : Config ): print ( f \"Oh, hi { args . name } !\" ) if __name__ == \"__main__\" : cli () When executed, this script will result in: $ python main.py --help > Usage: main.py [OPTIONS] > > Options: > --name TEXT How I should call you [default: Mark] > --help Show this message and exit. Informing the user that the name field is not strictly required, and in case it is not provided it will assume the value Mark . Command descriptions Likewise, it is also possible to provide a description to the command itself to be shown in as additional information in the help content. Following click , this is as simple as inserting docstrings under the decorated function: main.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from pydantic import BaseModel , Field from clidantic import Parser cli = Parser () class Config ( BaseModel ): name : str = Field ( description = \"How I should call you\" ) @cli . command () def hello ( args : Config ): \"\"\"Greets the user with the given name\"\"\" print ( f \"Oh, hi { args . name } !\" ) if __name__ == \"__main__\" : cli () Executing the help command will result in: $ python main.py --help > Usage: main.py [OPTIONS] > > Greets the user with the given name > > Options: > --name TEXT How I should call you [required] > --help Show this message and exit. Additional names and aliases Option names, especially in heavily nested models, can become difficult to type. As common practice in command line tools, clidantic offers the possibility to add additional names to each field. This feature is allowed by the custom CLIField operator: main.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 from pydantic import BaseModel from clidantic import Parser from clidantic.fields import CLIField cli = Parser () class Config ( BaseModel ): name : str = CLIField ( \"-n\" , \"--nombre\" , default = \"Mark\" , description = \"How I should call you\" ) @cli . command () def hello ( args : Config ): \"\"\"Greets the user with the given name\"\"\" print ( f \"Oh, hi { args . name } !\" ) if __name__ == \"__main__\" : cli () In this case, the output of the help command will be the following: $ python main.py --help > Usage: main.py [OPTIONS] > > Greets the user with the given name > > Options: > -n, --name, --nombre TEXT How I should call you [default: Mark] > --help Show this message and exit. In the example, you may have noticed a few things: - CLIField is not part of pydantic , it is a customized version present in clidantic . - The default argument has become a kwarg , instead of being the first positional argument. - The new field takes as first (optional) arguments a variable list of additional names for the field. Aside from these differences, the CLIField operator directly mirrors the standard Field functionality, therefore any other input or mechanism can be effectively used, see the description argument for instance. Warning When using optional names, keep in mind that the uniqueness is not verified , and nested models will not affect the result. In practice, fields such as main.subfield-a , if renamed sa will not need the main. prefix. However, this can be done manually. Consider this when providing additional names.","title":"Customization"},{"location":"guide/fields/#customization","text":"","title":"Customization"},{"location":"guide/fields/#the-help-directive","text":"As in every command line interface, before any actual command is executed it is often required to consult the help . As usual, to print the available commands and their options it is sufficient to execute the command with the --help/-h option. For instance, a script like the following: main.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from pydantic import BaseModel from clidantic import Parser cli = Parser () class Config ( BaseModel ): name : str @cli . command () def hello ( args : Config ): print ( f \"Hi, { args . name } !\" ) if __name__ == \"__main__\" : cli () Will provide the following output: $ python main.py --help > Usage: main.py [OPTIONS] > > Options: > --name TEXT [required] > --help Show this message and exit. As you can notice, every field from the configuration model parsed by the command is converted into a click option and displayed in the help . Each field has a name, a type, an optional required flag and its description. In this specific example, the description is present for the help command only, while the name is missing one.","title":"The help directive"},{"location":"guide/fields/#adding-descriptions","text":"Defining configurations through types only does not allow for descriptive definitions. Pydantic allows for field descriptions through the Field class: main.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from pydantic import BaseModel , Field from clidantic import Parser cli = Parser () class Config ( BaseModel ): name : str = Field ( description = \"How I should call you\" ) @cli . command () def hello ( args : Config ): print ( f \"Oh, hi { args . name } !\" ) if __name__ == \"__main__\" : cli () This will allow fields to have more details in the help output: $ python main.py --help > Usage: main.py [OPTIONS] > > Options: > --name TEXT How I should call you [required] > --help Show this message and exit.","title":"Adding descriptions"},{"location":"guide/fields/#default-values","text":"Models support default values by simply assigning them to the field: class Config ( BaseModel ): name : str = \"Mark\" age : int = 42 It is also possible to combine default values and descriptions through the Field class, for instance: main.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from pydantic import BaseModel , Field from clidantic import Parser cli = Parser () class Config ( BaseModel ): name : str = Field ( \"Mark\" , description = \"How I should call you\" ) @cli . command () def hello ( args : Config ): print ( f \"Oh, hi { args . name } !\" ) if __name__ == \"__main__\" : cli () When executed, this script will result in: $ python main.py --help > Usage: main.py [OPTIONS] > > Options: > --name TEXT How I should call you [default: Mark] > --help Show this message and exit. Informing the user that the name field is not strictly required, and in case it is not provided it will assume the value Mark .","title":"Default values"},{"location":"guide/fields/#command-descriptions","text":"Likewise, it is also possible to provide a description to the command itself to be shown in as additional information in the help content. Following click , this is as simple as inserting docstrings under the decorated function: main.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from pydantic import BaseModel , Field from clidantic import Parser cli = Parser () class Config ( BaseModel ): name : str = Field ( description = \"How I should call you\" ) @cli . command () def hello ( args : Config ): \"\"\"Greets the user with the given name\"\"\" print ( f \"Oh, hi { args . name } !\" ) if __name__ == \"__main__\" : cli () Executing the help command will result in: $ python main.py --help > Usage: main.py [OPTIONS] > > Greets the user with the given name > > Options: > --name TEXT How I should call you [required] > --help Show this message and exit.","title":"Command descriptions"},{"location":"guide/fields/#additional-names-and-aliases","text":"Option names, especially in heavily nested models, can become difficult to type. As common practice in command line tools, clidantic offers the possibility to add additional names to each field. This feature is allowed by the custom CLIField operator: main.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 from pydantic import BaseModel from clidantic import Parser from clidantic.fields import CLIField cli = Parser () class Config ( BaseModel ): name : str = CLIField ( \"-n\" , \"--nombre\" , default = \"Mark\" , description = \"How I should call you\" ) @cli . command () def hello ( args : Config ): \"\"\"Greets the user with the given name\"\"\" print ( f \"Oh, hi { args . name } !\" ) if __name__ == \"__main__\" : cli () In this case, the output of the help command will be the following: $ python main.py --help > Usage: main.py [OPTIONS] > > Greets the user with the given name > > Options: > -n, --name, --nombre TEXT How I should call you [default: Mark] > --help Show this message and exit. In the example, you may have noticed a few things: - CLIField is not part of pydantic , it is a customized version present in clidantic . - The default argument has become a kwarg , instead of being the first positional argument. - The new field takes as first (optional) arguments a variable list of additional names for the field. Aside from these differences, the CLIField operator directly mirrors the standard Field functionality, therefore any other input or mechanism can be effectively used, see the description argument for instance. Warning When using optional names, keep in mind that the uniqueness is not verified , and nested models will not affect the result. In practice, fields such as main.subfield-a , if renamed sa will not need the main. prefix. However, this can be done manually. Consider this when providing additional names.","title":"Additional names and aliases"},{"location":"guide/intro/","text":"Introduction Parsers The main building block of clidantic is represented by a Parser instance. Every CLI requires at least one active parser, which serves as main entry point. A parser simply acts as a collection of commands and arguments, which are only executed upon call. Any Parser must first be imported, instantiated, then called in a main, like so: main.py 1 2 3 4 5 6 7 8 9 from pydantic import BaseModel from clidantic import Parser cli = Parser () if __name__ == \"__main__\" : cli () However, this code is not enough to have a working CLI . If you attempt to run it you will obtain: $ python main.py > ValueError: CLI not initialized This is expected, it lacks any functionality, which is provided by commands and their arguments. Commands In order for a CLI to be ready for execution, it needs to know what to do: this information is provided through the command decorator. The following is the simplest working possible interface, which simply executes a function with a single print and exits (albeit without errors this time). main.py 1 2 3 4 5 6 7 8 9 10 11 12 from clidantic import Parser cli = Parser () @cli . command () def function (): print ( \"Hello world!\" ) if __name__ == \"__main__\" : cli () $ python main.py > Hello world! We are getting there, but the command function lacks arguments . Command arguments At the base of any command-line interface there is a pydantic BaseModel . Simply put, a model is a special Python class defining the structure of a single entity with its set of fields and their type. Each model field represents an input argument, whose appearance in the command line interface is dictated by its type and its options. For instance, a simple command with one argument, requires a model with one field: main.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from pydantic import BaseModel from clidantic import Parser cli = Parser () class Config ( BaseModel ): name : str @cli . command () def hello ( args : Config ): print ( f \"Hi, { args . name } !\" ) if __name__ == \"__main__\" : cli () CLI execution Models are automatically parsed into click options and associated with the decorated function. The available commands and their arguments can be inspected with the classical --help page: $ python main.py --help > Usage: main.py [OPTIONS] > > Options: > --name TEXT [required] > --help Show this message and exit. This informs us that the command requires options, specifically a name string, and of course the help directive. So, let's provide a name: $ python main.py --name Mark > Hi, Mark! Since you have a keen eye, you probably noticed that the option is marked as required . That's because we did not specify anything else to the model's name field, except for its type. Following pydantic 's logic, such field thus is handled as a required option by click as well: $ python main.py > Usage: main.py [OPTIONS] > Try 'main.py --help' for help. > > Error: Missing option '--name'. Later sections will provide more detail on optional and more complex arguments. In summary, clidantic requires three main ingredients: A function to be executed, very much like a click Command . A set of arguments , provided by a pydantic BaseModel . A Parser instance, that provides the glue between the arguments to the commands.","title":"Introduction"},{"location":"guide/intro/#introduction","text":"","title":"Introduction"},{"location":"guide/intro/#parsers","text":"The main building block of clidantic is represented by a Parser instance. Every CLI requires at least one active parser, which serves as main entry point. A parser simply acts as a collection of commands and arguments, which are only executed upon call. Any Parser must first be imported, instantiated, then called in a main, like so: main.py 1 2 3 4 5 6 7 8 9 from pydantic import BaseModel from clidantic import Parser cli = Parser () if __name__ == \"__main__\" : cli () However, this code is not enough to have a working CLI . If you attempt to run it you will obtain: $ python main.py > ValueError: CLI not initialized This is expected, it lacks any functionality, which is provided by commands and their arguments.","title":"Parsers"},{"location":"guide/intro/#commands","text":"In order for a CLI to be ready for execution, it needs to know what to do: this information is provided through the command decorator. The following is the simplest working possible interface, which simply executes a function with a single print and exits (albeit without errors this time). main.py 1 2 3 4 5 6 7 8 9 10 11 12 from clidantic import Parser cli = Parser () @cli . command () def function (): print ( \"Hello world!\" ) if __name__ == \"__main__\" : cli () $ python main.py > Hello world! We are getting there, but the command function lacks arguments .","title":"Commands"},{"location":"guide/intro/#command-arguments","text":"At the base of any command-line interface there is a pydantic BaseModel . Simply put, a model is a special Python class defining the structure of a single entity with its set of fields and their type. Each model field represents an input argument, whose appearance in the command line interface is dictated by its type and its options. For instance, a simple command with one argument, requires a model with one field: main.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from pydantic import BaseModel from clidantic import Parser cli = Parser () class Config ( BaseModel ): name : str @cli . command () def hello ( args : Config ): print ( f \"Hi, { args . name } !\" ) if __name__ == \"__main__\" : cli ()","title":"Command arguments"},{"location":"guide/intro/#cli-execution","text":"Models are automatically parsed into click options and associated with the decorated function. The available commands and their arguments can be inspected with the classical --help page: $ python main.py --help > Usage: main.py [OPTIONS] > > Options: > --name TEXT [required] > --help Show this message and exit. This informs us that the command requires options, specifically a name string, and of course the help directive. So, let's provide a name: $ python main.py --name Mark > Hi, Mark! Since you have a keen eye, you probably noticed that the option is marked as required . That's because we did not specify anything else to the model's name field, except for its type. Following pydantic 's logic, such field thus is handled as a required option by click as well: $ python main.py > Usage: main.py [OPTIONS] > Try 'main.py --help' for help. > > Error: Missing option '--name'. Later sections will provide more detail on optional and more complex arguments. In summary, clidantic requires three main ingredients: A function to be executed, very much like a click Command . A set of arguments , provided by a pydantic BaseModel . A Parser instance, that provides the glue between the arguments to the commands.","title":"CLI execution"},{"location":"guide/nesting/","text":"Nested Commands Probably the most important click feature is represented by command groups , where commands can be nested to create an interface with multiple commands. The following sections provide a detailed view on how this functionality is supported in clidantic . The Parser class Command groups are natively supported in clidantic through the Parser class: each Parser acts seamlessly either as command when only one is available, or as a group of commands when more than one is added to it. The following CLI only contains one command: single.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from pydantic import BaseModel from clidantic import Parser class Item ( BaseModel ): name : str price : float = 0.0 cli = Parser ( name = \"items\" ) @cli . command () def buy ( item : Item ): print ( f \"Bought { item . name } for $ { item . price : .2f } \" ) if __name__ == \"__main__\" : cli () When executing the help, since there's no other option, clidantic immediately shows the help for the buy command, thus acting as a single click Command : $ python single.py --help > Usage: single.py [OPTIONS] > > Options: > --name TEXT [required] > --price FLOAT [default: 0.0] > --help Show this message and exit. Parsers can handle a list of commands without explicit nesting, internally creating a click group. When there is more than one choice, the function name is necessary to execute the correct command. For instance, with two commands: multi.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from pydantic import BaseModel from clidantic import Parser class Item ( BaseModel ): name : str price : float = 0.0 cli = Parser ( name = \"items\" ) @cli . command () def buy ( item : Item ): print ( f \"Bought { item . name } for $ { item . price : .2f } \" ) @cli . command () def sell ( item : Item ): print ( f \"Sold { item . name } for $ { item . price : .2f } \" ) if __name__ == \"__main__\" : cli () The help will provide the following information: $ python multi.py --help > Usage: multi.py [OPTIONS] COMMAND [ARGS]... > > Options: > --help Show this message and exit. > > Commands: > buy > sell The input description for the required fields will only be provided on the help of the specific command itself. Of course, input parameters are provided after the command name: $ python multi.py buy --help > Usage: multi.py buy [OPTIONS] > > Options: > --name TEXT [required] > --price FLOAT [default: 0.0] > --help Show this message and exit. $ python multi.py buy --name bananas --price 2 .0 > Bought bananas for $2.00 Warning The support for groups and nested commands is still experimental. Please report any advanced functionality that is currently missing. Combining multiple parsers In click, commands and groups can be repeatedly combined and nested to form a tree-like structure of functions. This is extremely useful to organize more complex tools, imagine something like git , which provides multiple complex sub-commands. In clidantic , this feature is supported through the Parser.merge option: nested.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 from pydantic import BaseModel from clidantic import Parser class Item ( BaseModel ): name : str price : float = 0.0 # the name is required for nested CLIs items = Parser ( name = \"items\" ) store = Parser ( name = \"store\" ) @items . command () def buy ( item : Item ): print ( f \"Bought { item . name } for $ { item . price : .2f } \" ) @items . command () def sell ( item : Item ): print ( f \"Sold { item . name } for $ { item . price : .2f } \" ) @store . command () def add ( item : Item ): print ( f \"Added { item . name } to the store\" ) @store . command () def remove ( item : Item ): print ( f \"Removed { item . name } from the store\" ) # now the command groups can be merged together cli = Parser . merge ( items , store ) if __name__ == \"__main__\" : cli () In this specific case, every Parser instance requires its own name, so that the user can select the right group during the execution. Of course, the help and command invocation will reflect this command hierachy: $ python nested.py --help > Usage: nested.py [OPTIONS] COMMAND [ARGS]... > > Options: > --help Show this message and exit. > > Commands: > items > store $ python nested.py store --help > Usage: nested.py store [OPTIONS] COMMAND [ARGS]... > > Options: > --help Show this message and exit. > > Commands: > add > remove $ python nested.py store add --help Usage: nested.py store add [OPTIONS] > > Options: > --name TEXT [required] > --price FLOAT [default: 0.0] > --help Show this message and exit. $ python nested.py store add --name tomatoes --price 4 .0 > Added tomatoes to the store","title":"Nested Commands"},{"location":"guide/nesting/#nested-commands","text":"Probably the most important click feature is represented by command groups , where commands can be nested to create an interface with multiple commands. The following sections provide a detailed view on how this functionality is supported in clidantic .","title":"Nested Commands"},{"location":"guide/nesting/#the-parser-class","text":"Command groups are natively supported in clidantic through the Parser class: each Parser acts seamlessly either as command when only one is available, or as a group of commands when more than one is added to it. The following CLI only contains one command: single.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from pydantic import BaseModel from clidantic import Parser class Item ( BaseModel ): name : str price : float = 0.0 cli = Parser ( name = \"items\" ) @cli . command () def buy ( item : Item ): print ( f \"Bought { item . name } for $ { item . price : .2f } \" ) if __name__ == \"__main__\" : cli () When executing the help, since there's no other option, clidantic immediately shows the help for the buy command, thus acting as a single click Command : $ python single.py --help > Usage: single.py [OPTIONS] > > Options: > --name TEXT [required] > --price FLOAT [default: 0.0] > --help Show this message and exit. Parsers can handle a list of commands without explicit nesting, internally creating a click group. When there is more than one choice, the function name is necessary to execute the correct command. For instance, with two commands: multi.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from pydantic import BaseModel from clidantic import Parser class Item ( BaseModel ): name : str price : float = 0.0 cli = Parser ( name = \"items\" ) @cli . command () def buy ( item : Item ): print ( f \"Bought { item . name } for $ { item . price : .2f } \" ) @cli . command () def sell ( item : Item ): print ( f \"Sold { item . name } for $ { item . price : .2f } \" ) if __name__ == \"__main__\" : cli () The help will provide the following information: $ python multi.py --help > Usage: multi.py [OPTIONS] COMMAND [ARGS]... > > Options: > --help Show this message and exit. > > Commands: > buy > sell The input description for the required fields will only be provided on the help of the specific command itself. Of course, input parameters are provided after the command name: $ python multi.py buy --help > Usage: multi.py buy [OPTIONS] > > Options: > --name TEXT [required] > --price FLOAT [default: 0.0] > --help Show this message and exit. $ python multi.py buy --name bananas --price 2 .0 > Bought bananas for $2.00 Warning The support for groups and nested commands is still experimental. Please report any advanced functionality that is currently missing.","title":"The Parser class"},{"location":"guide/nesting/#combining-multiple-parsers","text":"In click, commands and groups can be repeatedly combined and nested to form a tree-like structure of functions. This is extremely useful to organize more complex tools, imagine something like git , which provides multiple complex sub-commands. In clidantic , this feature is supported through the Parser.merge option: nested.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 from pydantic import BaseModel from clidantic import Parser class Item ( BaseModel ): name : str price : float = 0.0 # the name is required for nested CLIs items = Parser ( name = \"items\" ) store = Parser ( name = \"store\" ) @items . command () def buy ( item : Item ): print ( f \"Bought { item . name } for $ { item . price : .2f } \" ) @items . command () def sell ( item : Item ): print ( f \"Sold { item . name } for $ { item . price : .2f } \" ) @store . command () def add ( item : Item ): print ( f \"Added { item . name } to the store\" ) @store . command () def remove ( item : Item ): print ( f \"Removed { item . name } from the store\" ) # now the command groups can be merged together cli = Parser . merge ( items , store ) if __name__ == \"__main__\" : cli () In this specific case, every Parser instance requires its own name, so that the user can select the right group during the execution. Of course, the help and command invocation will reflect this command hierachy: $ python nested.py --help > Usage: nested.py [OPTIONS] COMMAND [ARGS]... > > Options: > --help Show this message and exit. > > Commands: > items > store $ python nested.py store --help > Usage: nested.py store [OPTIONS] COMMAND [ARGS]... > > Options: > --help Show this message and exit. > > Commands: > add > remove $ python nested.py store add --help Usage: nested.py store add [OPTIONS] > > Options: > --name TEXT [required] > --price FLOAT [default: 0.0] > --help Show this message and exit. $ python nested.py store add --name tomatoes --price 4 .0 > Added tomatoes to the store","title":"Combining multiple parsers"},{"location":"guide/types/","text":"Field Types Thanks to features provided by click and especially pydantic data definitions, clidantic supports a large amount of field types, from the standard library up to JSON inputs. Primitive types Considering primitive, non-complex data types, the library supports the following: str : values accepted as is, parsed as simple text without further processing. int : tries to convert any given input into an integer through int(value) . float : similarly, tries to convert any given input into a floating point number through float(value) bytes : similar to strings, however in this case the underlying representation remains bytes . bool : by default, booleans are intended as flag options. In this case any boolean field will have the corresponding CLI flag --field/--no-field . Clidantic takes care of converting pydantic field types into click parameter types, so that the automatically generated description reamins as faithful as possible. Bear in mind that click types are exploited only for documentation purposes, the final type checking will be carried out by pydantic when it's not validated by click . Moreover, more complex types will default to str in most cases. Here's an example of script with primitive types: main.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 from pydantic import BaseModel from clidantic import Parser cli = Parser () class Register ( BaseModel ): name : str count : int amount : float paid : bool beep_bop : bytes @cli . command () def status ( register : Register ): print ( f \"Register: { register . name } \" ) print ( f \"bills: { register . count } \" ) print ( f \"amount: $ { register . amount : .2f } \" ) status = \"closed\" if register . paid else \"open\" print ( f \"status: { status } \" ) print ( f \"bytes: { register . beep_bop } \" ) if __name__ == \"__main__\" : cli () The help will show the specific type required in input $ python primitives.py --help > Usage: primitives.py [OPTIONS] > > Options: > --name TEXT [required] > --count INTEGER [required] > --amount FLOAT [required] > --paid / --no-paid [required] > --beep-bop BYTES [required] > --help Show this message and exit. Data is validated before the actual execution. In case of failure, a meaningful message will be displayed: $ python primitives.py --count hello > Usage: primitives.py [OPTIONS] > Try 'primitive_types.py --help' for help. > > Error: Invalid value for '--count': 'hello' is not a valid integer. Complex types Thanks to pydantic, a large amount of complex and composable field types can be exploited. Currently, the complex types that have been tested through clidantic are the following: Standard Library Types Generally speaking, non-typed complex types will default to strings unless specified otherwise. list : without specifying the internal type, list fields will behave as multiple options of string items. With Multiple Options , the parameter must be provided multiple times. For instance, python cli.py --add 1 --add 2 will result in a list [1, 2] . tuple : similar to lists, this will behave as an unbounded sequence of strings, with multiple parameters. dict : dictionaries are interpreted as JSON strings. In this case, there will be no further validation. Given that valid JSON strings require double quotes, arguments provided through the command line must use single-quoted strings. For instance, python cli.py --extras '{\"items\": 12}' will be successfully parsed, while python cli.py --extras \"{'items': 12}\" will not. set : again, from a command line point of view, sets are a simple list of values. In this case, repeated values will be excluded. For instance, python cli.py --add a --add b --add a will result in a set {'a', 'b'} . frozenset : frozen sets adopt the same behavior as normal sets, with the only difference that they remain immutable. deque : similarly, deques act as sequences from a CLI standpoint, while being treaded as double-ended queues in code. Typing Containers Any : For obvious reasons, Any fields will behave as str options without further processing. Optional : optional typing can be interpreted as syntactic sugar , meaning it will not have any effect on the underlying validation, but it provides an explicit declaration that the field can also accept None as value. For the CLI, Optional will automatically add a None default value to the field, indeed bahaving as an optional parameter. List : Similar to standard lists, typing Lists behave as sequences of items. In this case however the inner type is exploited to provide further validation through pydantic . For instance, python cli.py --add a --add b will result in a validation error for a list of integers List[int] . Tuple : typing Tuples can behave in two ways: when using a variable length structure (i.e., Tuple[int] or Tuple[int, ...] ), tuples act as a sequence of typed items, validated through pydantic, where the parameter is specified multiple times. When using a _fixed length structure (i.e., Tuple[int, int] or similar), they are considered multi-value options , where the parameter is specified once, followed by the sequence of values separated by whitespaces. For instance . python cli.py --items a b c will results in a tuple ('a', 'b', 'c') . Dict : Similar to the standard dict field, typing dictionaries require a JSON string as input. However, inner types allow for a finer validation: for instance, considering a metrics: Dict[str, float] field, --metrics '{\"f1\": 0.93}' is accepted, while --metrics '{\"auc\": \"a\"}' is not a valid input. Deque : with the same reasoning of typed lists and tuples, Deques will act as sequences with a specific type. Set : As you guessed, typed sets act as multiple options where repeated items are excluded, with additional type validation on the items themselves. FrozenSet : as with Sets , but they represent immutable structures after parsing. Sequence : with no surpise, sequences act as sequences, nothing to add here. Warning for obvious reasons, Union typings are not supported at this time. Parsing a multi-valued parameter is really more of a phylosophical problem than a technical one. Future releases will consider the support for this typing. The code below provides a relatively comprehensive view of most container types supported through clidantic . The list is not exhaustive: broadly speaking, the logic for the parameter definition can be summarized as follows: if it is any other complex supported type then provide the specific type if it is a container type then : if it has no inner type then behave as sequence of strings if it has one inner type T , or T with ellipsis, behave as sequence of type T if it has 2+ inner types without ellipsis, behave as fixed-length sequence with the given list of types else left click attempt the type inference, worst case scenario will be str complex.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 from typing import Deque , Dict , FrozenSet , List , Optional , Sequence , Set , Tuple from pydantic import BaseModel from clidantic import Parser cli = Parser () class Model ( BaseModel ): # lists use typed options, called more than once # non-typed lists will act as list of strings simple_list : list = None list_of_ints : List [ int ] = None # unbound tuples work like lists # more specific tuples require multi-arg inputs simple_tuple : tuple = None multi_typed_tuple : Tuple [ int , float , str , bool ] = None # dictionaries are interpreted as JSON strings simple_dict : dict = None dict_str_float : Dict [ str , float ] = None # sets will also use multiple options, filtering duplicates # non-typed sets will behave as string sets simple_set : set = None set_bytes : Set [ bytes ] = None frozen_set : FrozenSet [ int ] = None # Optional can be added for readability, doesn't affect parsing # Everything belonging to iterables adopts multiple options # Mappings also supported more thorough validation none_or_str : Optional [ str ] = None sequence_of_ints : Sequence [ int ] = None compound : Dict [ str , List [ Set [ int ]]] = None deque : Deque [ int ] = None @cli . command () def run ( items : Model ): for k , v in items . dict () . items (): print ( f \" { k : <20s } : { str ( v ) } \" ) if __name__ == \"__main__\" : cli () Executing this script with the help command will provide the description for the current configuration. There are a few things to notice here: when possible and specified, clidantic will show the time of the item accepted by the multi-option fields, otherwise it will appear as TEXT . Also, defaults are allowed and validated: when optional or None , a more descriptive (empty <TYPE>) will inform the user of the underlying iterable class. $ python complex.py --help > Usage: complex.py [OPTIONS] > > Options: > --simple-list TEXT [default: (empty list)] > --list-of-ints INTEGER [default: (empty list)] > --simple-tuple TEXT [default: (empty tuple)] > --multi-typed-tuple <INTEGER FLOAT TEXT BOOLEAN>... > [default: (empty tuple)] > --simple-dict JSON [default: (empty dict)] > --dict-str-float JSON [default: (empty dict)] > --simple-set TEXT [default: (empty set)] > --set-bytes BYTES [default: (empty set)] > --frozen-set INTEGER [default: (empty frozenset)] > --none-or-str TEXT > --sequence-of-ints INTEGER [default: (empty Sequence)] > --compound JSON [default: (empty dict)] > --deque INTEGER [default: (empty deque)] > --help Show this message and exit. Literals and Enums Sometimes it may be useful to directly limit the choices of certain fields, by letting the user select among a fixed list of values. In this case, clidantic provides this feature using pydantic 's support for Enum and Literal types, parsed from the command line through click Choice derivatives. While Enums represent the standard way to provide choice-based options, Literals can be seen as a lightweight enumeration. In general, the latter are simpler and easier to handle than the former for most use cases. Enums on the other hand provide both a name and a value component, where only the former is exploited for the parameter definition. The latter can represent any kind of object, therefore making enums more suitable for more complex use cases. The following script presents a sample of possible choice definitions in clidantic : choices.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 from enum import Enum , IntEnum from typing import Literal from pydantic import BaseModel from clidantic import Parser cli = Parser () class ToolEnum ( Enum ): hammer = \"Hammer\" screwdriver = \"Screwdriver\" class HTTPEnum ( IntEnum ): ok = 200 not_found = 404 interal_error = 500 class Settings ( BaseModel ): a : Literal [ \"one\" , \"two\" ] b : Literal [ 1 , 2 ] = 2 c : Literal [ True , False ] d : ToolEnum e : HTTPEnum = HTTPEnum . not_found @cli . command () def run ( settings : Settings ): for k , v in settings . dict () . items (): print ( f \" { k : <20s } : { str ( v ) } \" ) if __name__ == \"__main__\" : cli () Warning As you probably noticed, the string enumeration only subclasses Enum . Strictly speaking, ToolEnum(str, Enum) would be a better inheritance definition, however this breaks the type inference by providing two origins. Currently, there are two solutions: simply use Enum , it should be fine in most cases. use StrEnum , which however is only available since Python 3.11. Launching the help for this script will result in the following output: $ python choices.py --help > Usage: choices.py [OPTIONS] > > Options: > --a [one|two] [required] > --b [1|2] [default: 2] > --c [True|False] [required] > --d [hammer|screwdriver] [required] > --e [ok|not_found|interal_error] > [default: not_found] > --help Show this message and exit. You can notice that, even without explicit description, choice-based fields will automatically provide the list of possible values. Defaults also behave as expected: both literals and enums will accept any of the allowed values as default, and it that case the selected item will be displayed as default in the console. Again, note that the name field enum-based choice parameters is handled by the CLI, not its actual value. Module Types For peculiar use cases, where the aim is to dinamically import a specific module, fields can be annotated with the Type type for module-like parameters. Specifying field: Type[T] , pydantic will ensure that field will assume as values only classes (not instances) that are subclasses of T . Note Support for module types is still experimental at this point. Here's an example of module type definition: modules.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 from typing import Type from pydantic import BaseModel from clidantic import Parser class Optimizer : \"\"\" Example of base abstract class \"\"\" class SGD ( Optimizer ): \"\"\" A specific optimizer implementation \"\"\" class Adam ( Optimizer ): \"\"\" Another specific optimizer implementation \"\"\" class Settings ( BaseModel ): field : Type [ Optimizer ] = SGD cli = Parser () @cli . command () def run ( config : Settings ): print ( config . field ) if __name__ == \"__main__\" : cli () Again, the help command will results in the following output: $ python modules.py --help > Usage: modules.py [OPTIONS] > > Options: > --field MODULE [default: __main__.SGD] > --help Show this message and exit. The example is meant to be a contained, working example, however it is not recommended to place both the CLI instance and the modules to be selected in the same script, as Python's weird importing and execution mechanisms may become a problem. For instance, it this case the default modules.SGD class appears to belong to the __main__ module. This is in fact the name that Python will set on the top-level entry point , regardless of the script name. Nevertheless, module types basically require an import path to the correct module (not file), which in this case corresponds to __main__ . So, if we run python module_types.py --field __main__.Adam , we will obtain the correct assignment to the module field: $ python modules.py --field __main__.Adam > <class '__main__.Adam'> While wrong paths will of course result in an error, informing the user about the mistake: $ python modules.py --field myscript.MyClass > Try 'modules.py --help' for help. > > Error: Invalid value for '--field': 'myscript.MyClass' is not a valid object (<class 'ModuleNotFoundError'>: No module named 'myscript')","title":"Field Types"},{"location":"guide/types/#field-types","text":"Thanks to features provided by click and especially pydantic data definitions, clidantic supports a large amount of field types, from the standard library up to JSON inputs.","title":"Field Types"},{"location":"guide/types/#primitive-types","text":"Considering primitive, non-complex data types, the library supports the following: str : values accepted as is, parsed as simple text without further processing. int : tries to convert any given input into an integer through int(value) . float : similarly, tries to convert any given input into a floating point number through float(value) bytes : similar to strings, however in this case the underlying representation remains bytes . bool : by default, booleans are intended as flag options. In this case any boolean field will have the corresponding CLI flag --field/--no-field . Clidantic takes care of converting pydantic field types into click parameter types, so that the automatically generated description reamins as faithful as possible. Bear in mind that click types are exploited only for documentation purposes, the final type checking will be carried out by pydantic when it's not validated by click . Moreover, more complex types will default to str in most cases. Here's an example of script with primitive types: main.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 from pydantic import BaseModel from clidantic import Parser cli = Parser () class Register ( BaseModel ): name : str count : int amount : float paid : bool beep_bop : bytes @cli . command () def status ( register : Register ): print ( f \"Register: { register . name } \" ) print ( f \"bills: { register . count } \" ) print ( f \"amount: $ { register . amount : .2f } \" ) status = \"closed\" if register . paid else \"open\" print ( f \"status: { status } \" ) print ( f \"bytes: { register . beep_bop } \" ) if __name__ == \"__main__\" : cli () The help will show the specific type required in input $ python primitives.py --help > Usage: primitives.py [OPTIONS] > > Options: > --name TEXT [required] > --count INTEGER [required] > --amount FLOAT [required] > --paid / --no-paid [required] > --beep-bop BYTES [required] > --help Show this message and exit. Data is validated before the actual execution. In case of failure, a meaningful message will be displayed: $ python primitives.py --count hello > Usage: primitives.py [OPTIONS] > Try 'primitive_types.py --help' for help. > > Error: Invalid value for '--count': 'hello' is not a valid integer.","title":"Primitive types"},{"location":"guide/types/#complex-types","text":"Thanks to pydantic, a large amount of complex and composable field types can be exploited. Currently, the complex types that have been tested through clidantic are the following:","title":"Complex types"},{"location":"guide/types/#standard-library-types","text":"Generally speaking, non-typed complex types will default to strings unless specified otherwise. list : without specifying the internal type, list fields will behave as multiple options of string items. With Multiple Options , the parameter must be provided multiple times. For instance, python cli.py --add 1 --add 2 will result in a list [1, 2] . tuple : similar to lists, this will behave as an unbounded sequence of strings, with multiple parameters. dict : dictionaries are interpreted as JSON strings. In this case, there will be no further validation. Given that valid JSON strings require double quotes, arguments provided through the command line must use single-quoted strings. For instance, python cli.py --extras '{\"items\": 12}' will be successfully parsed, while python cli.py --extras \"{'items': 12}\" will not. set : again, from a command line point of view, sets are a simple list of values. In this case, repeated values will be excluded. For instance, python cli.py --add a --add b --add a will result in a set {'a', 'b'} . frozenset : frozen sets adopt the same behavior as normal sets, with the only difference that they remain immutable. deque : similarly, deques act as sequences from a CLI standpoint, while being treaded as double-ended queues in code.","title":"Standard Library Types"},{"location":"guide/types/#typing-containers","text":"Any : For obvious reasons, Any fields will behave as str options without further processing. Optional : optional typing can be interpreted as syntactic sugar , meaning it will not have any effect on the underlying validation, but it provides an explicit declaration that the field can also accept None as value. For the CLI, Optional will automatically add a None default value to the field, indeed bahaving as an optional parameter. List : Similar to standard lists, typing Lists behave as sequences of items. In this case however the inner type is exploited to provide further validation through pydantic . For instance, python cli.py --add a --add b will result in a validation error for a list of integers List[int] . Tuple : typing Tuples can behave in two ways: when using a variable length structure (i.e., Tuple[int] or Tuple[int, ...] ), tuples act as a sequence of typed items, validated through pydantic, where the parameter is specified multiple times. When using a _fixed length structure (i.e., Tuple[int, int] or similar), they are considered multi-value options , where the parameter is specified once, followed by the sequence of values separated by whitespaces. For instance . python cli.py --items a b c will results in a tuple ('a', 'b', 'c') . Dict : Similar to the standard dict field, typing dictionaries require a JSON string as input. However, inner types allow for a finer validation: for instance, considering a metrics: Dict[str, float] field, --metrics '{\"f1\": 0.93}' is accepted, while --metrics '{\"auc\": \"a\"}' is not a valid input. Deque : with the same reasoning of typed lists and tuples, Deques will act as sequences with a specific type. Set : As you guessed, typed sets act as multiple options where repeated items are excluded, with additional type validation on the items themselves. FrozenSet : as with Sets , but they represent immutable structures after parsing. Sequence : with no surpise, sequences act as sequences, nothing to add here. Warning for obvious reasons, Union typings are not supported at this time. Parsing a multi-valued parameter is really more of a phylosophical problem than a technical one. Future releases will consider the support for this typing. The code below provides a relatively comprehensive view of most container types supported through clidantic . The list is not exhaustive: broadly speaking, the logic for the parameter definition can be summarized as follows: if it is any other complex supported type then provide the specific type if it is a container type then : if it has no inner type then behave as sequence of strings if it has one inner type T , or T with ellipsis, behave as sequence of type T if it has 2+ inner types without ellipsis, behave as fixed-length sequence with the given list of types else left click attempt the type inference, worst case scenario will be str complex.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 from typing import Deque , Dict , FrozenSet , List , Optional , Sequence , Set , Tuple from pydantic import BaseModel from clidantic import Parser cli = Parser () class Model ( BaseModel ): # lists use typed options, called more than once # non-typed lists will act as list of strings simple_list : list = None list_of_ints : List [ int ] = None # unbound tuples work like lists # more specific tuples require multi-arg inputs simple_tuple : tuple = None multi_typed_tuple : Tuple [ int , float , str , bool ] = None # dictionaries are interpreted as JSON strings simple_dict : dict = None dict_str_float : Dict [ str , float ] = None # sets will also use multiple options, filtering duplicates # non-typed sets will behave as string sets simple_set : set = None set_bytes : Set [ bytes ] = None frozen_set : FrozenSet [ int ] = None # Optional can be added for readability, doesn't affect parsing # Everything belonging to iterables adopts multiple options # Mappings also supported more thorough validation none_or_str : Optional [ str ] = None sequence_of_ints : Sequence [ int ] = None compound : Dict [ str , List [ Set [ int ]]] = None deque : Deque [ int ] = None @cli . command () def run ( items : Model ): for k , v in items . dict () . items (): print ( f \" { k : <20s } : { str ( v ) } \" ) if __name__ == \"__main__\" : cli () Executing this script with the help command will provide the description for the current configuration. There are a few things to notice here: when possible and specified, clidantic will show the time of the item accepted by the multi-option fields, otherwise it will appear as TEXT . Also, defaults are allowed and validated: when optional or None , a more descriptive (empty <TYPE>) will inform the user of the underlying iterable class. $ python complex.py --help > Usage: complex.py [OPTIONS] > > Options: > --simple-list TEXT [default: (empty list)] > --list-of-ints INTEGER [default: (empty list)] > --simple-tuple TEXT [default: (empty tuple)] > --multi-typed-tuple <INTEGER FLOAT TEXT BOOLEAN>... > [default: (empty tuple)] > --simple-dict JSON [default: (empty dict)] > --dict-str-float JSON [default: (empty dict)] > --simple-set TEXT [default: (empty set)] > --set-bytes BYTES [default: (empty set)] > --frozen-set INTEGER [default: (empty frozenset)] > --none-or-str TEXT > --sequence-of-ints INTEGER [default: (empty Sequence)] > --compound JSON [default: (empty dict)] > --deque INTEGER [default: (empty deque)] > --help Show this message and exit.","title":"Typing Containers"},{"location":"guide/types/#literals-and-enums","text":"Sometimes it may be useful to directly limit the choices of certain fields, by letting the user select among a fixed list of values. In this case, clidantic provides this feature using pydantic 's support for Enum and Literal types, parsed from the command line through click Choice derivatives. While Enums represent the standard way to provide choice-based options, Literals can be seen as a lightweight enumeration. In general, the latter are simpler and easier to handle than the former for most use cases. Enums on the other hand provide both a name and a value component, where only the former is exploited for the parameter definition. The latter can represent any kind of object, therefore making enums more suitable for more complex use cases. The following script presents a sample of possible choice definitions in clidantic : choices.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 from enum import Enum , IntEnum from typing import Literal from pydantic import BaseModel from clidantic import Parser cli = Parser () class ToolEnum ( Enum ): hammer = \"Hammer\" screwdriver = \"Screwdriver\" class HTTPEnum ( IntEnum ): ok = 200 not_found = 404 interal_error = 500 class Settings ( BaseModel ): a : Literal [ \"one\" , \"two\" ] b : Literal [ 1 , 2 ] = 2 c : Literal [ True , False ] d : ToolEnum e : HTTPEnum = HTTPEnum . not_found @cli . command () def run ( settings : Settings ): for k , v in settings . dict () . items (): print ( f \" { k : <20s } : { str ( v ) } \" ) if __name__ == \"__main__\" : cli () Warning As you probably noticed, the string enumeration only subclasses Enum . Strictly speaking, ToolEnum(str, Enum) would be a better inheritance definition, however this breaks the type inference by providing two origins. Currently, there are two solutions: simply use Enum , it should be fine in most cases. use StrEnum , which however is only available since Python 3.11. Launching the help for this script will result in the following output: $ python choices.py --help > Usage: choices.py [OPTIONS] > > Options: > --a [one|two] [required] > --b [1|2] [default: 2] > --c [True|False] [required] > --d [hammer|screwdriver] [required] > --e [ok|not_found|interal_error] > [default: not_found] > --help Show this message and exit. You can notice that, even without explicit description, choice-based fields will automatically provide the list of possible values. Defaults also behave as expected: both literals and enums will accept any of the allowed values as default, and it that case the selected item will be displayed as default in the console. Again, note that the name field enum-based choice parameters is handled by the CLI, not its actual value.","title":"Literals and Enums"},{"location":"guide/types/#module-types","text":"For peculiar use cases, where the aim is to dinamically import a specific module, fields can be annotated with the Type type for module-like parameters. Specifying field: Type[T] , pydantic will ensure that field will assume as values only classes (not instances) that are subclasses of T . Note Support for module types is still experimental at this point. Here's an example of module type definition: modules.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 from typing import Type from pydantic import BaseModel from clidantic import Parser class Optimizer : \"\"\" Example of base abstract class \"\"\" class SGD ( Optimizer ): \"\"\" A specific optimizer implementation \"\"\" class Adam ( Optimizer ): \"\"\" Another specific optimizer implementation \"\"\" class Settings ( BaseModel ): field : Type [ Optimizer ] = SGD cli = Parser () @cli . command () def run ( config : Settings ): print ( config . field ) if __name__ == \"__main__\" : cli () Again, the help command will results in the following output: $ python modules.py --help > Usage: modules.py [OPTIONS] > > Options: > --field MODULE [default: __main__.SGD] > --help Show this message and exit. The example is meant to be a contained, working example, however it is not recommended to place both the CLI instance and the modules to be selected in the same script, as Python's weird importing and execution mechanisms may become a problem. For instance, it this case the default modules.SGD class appears to belong to the __main__ module. This is in fact the name that Python will set on the top-level entry point , regardless of the script name. Nevertheless, module types basically require an import path to the correct module (not file), which in this case corresponds to __main__ . So, if we run python module_types.py --field __main__.Adam , we will obtain the correct assignment to the module field: $ python modules.py --field __main__.Adam > <class '__main__.Adam'> While wrong paths will of course result in an error, informing the user about the mistake: $ python modules.py --field myscript.MyClass > Try 'modules.py --help' for help. > > Error: Invalid value for '--field': 'myscript.MyClass' is not a valid object (<class 'ModuleNotFoundError'>: No module named 'myscript')","title":"Module Types"}]}